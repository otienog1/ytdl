# YTD Multi-Server Load Balancer Configuration
# Replaces the existing single-server proxy configuration
# Preserves SSL certificates and WebSocket support

# Upstream backend servers (Load Balanced)
upstream ytd_backend {
    # Load balancing method: least_conn (send to server with fewest connections)
    least_conn;

    # Server 1 - ytd.timobosafaris.com (172.234.172.191) - Account A
    # Local backend on this server
    server 127.0.0.1:3001 max_fails=3 fail_timeout=30s;

    # Server 2 - GCP Instance (34.57.68.120) - Account B
    server 34.57.68.120:3001 max_fails=3 fail_timeout=30s;

    # Server 3 - AWS Instance (13.60.71.187) - Account C
    server 13.60.71.187:3001 max_fails=3 fail_timeout=30s;

    # Keepalive connections to backends
    keepalive 32;
}

# HTTPS Server Block
server {
    listen 443 ssl http2;
    server_name ytd.timobosafaris.com;

    # SSL Configuration (managed by Certbot)
    ssl_certificate /etc/letsencrypt/live/ytd.timobosafaris.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/ytd.timobosafaris.com/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # Logging
    access_log /var/log/nginx/ytd-lb-access.log;
    error_log /var/log/nginx/ytd-lb-error.log;

    # Client body size (for large video uploads if needed)
    client_max_body_size 100M;

    # Proxy headers (applied to all locations)
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_http_version 1.1;

    # WebSocket endpoint - MUST be before general location block
    location /ws/ {
        proxy_pass http://ytd_backend;

        # WebSocket upgrade headers
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # WebSocket timeouts (24 hours)
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
        proxy_connect_timeout 75s;

        # Retry on next server if WebSocket connection fails
        proxy_next_upstream error timeout http_503;
        proxy_next_upstream_tries 3;
    }

    # API endpoints with automatic failover
    location /api/ {
        proxy_pass http://ytd_backend;

        # Timeouts for API requests
        proxy_read_timeout 300s;
        proxy_connect_timeout 75s;
        proxy_send_timeout 300s;

        # Enable retries on next server if current fails
        # HTTP 503 = cookies unavailable, try next server
        proxy_next_upstream error timeout http_503;
        proxy_next_upstream_tries 3;
        proxy_next_upstream_timeout 10s;

        # Intercept 503 errors for failover
        proxy_intercept_errors on;
        error_page 503 = @retry_backend;
    }

    # Health check endpoint (proxies /health to /api/health/ on backend)
    # Note: FastAPI requires trailing slash for this endpoint
    location = /health {
        proxy_pass http://ytd_backend/api/health/;
        proxy_next_upstream off;
        proxy_connect_timeout 5s;
        proxy_read_timeout 5s;
    }

    # Alternative: proxy /api/health to /api/health/ (with redirect handling)
    location = /api/health {
        proxy_pass http://ytd_backend/api/health/;
        proxy_next_upstream off;
        proxy_connect_timeout 5s;
        proxy_read_timeout 5s;
    }

    # Metrics endpoint (Prometheus)
    location /metrics {
        proxy_pass http://ytd_backend/metrics;
        proxy_next_upstream off;
    }

    # General catch-all location
    location / {
        proxy_pass http://ytd_backend;

        # Timeouts
        proxy_read_timeout 300s;
        proxy_connect_timeout 75s;
        proxy_send_timeout 300s;

        # Retry on errors
        proxy_next_upstream error timeout http_503;
        proxy_next_upstream_tries 2;
    }

    # Retry location for 503 errors
    location @retry_backend {
        proxy_pass http://ytd_backend;
        proxy_next_upstream error timeout http_503;
        proxy_next_upstream_tries 2;
    }
}

# HTTP to HTTPS Redirect
server {
    listen 80;
    server_name ytd.timobosafaris.com;

    # Redirect all HTTP traffic to HTTPS
    return 301 https://$host$request_uri;
}

# Admin/Monitoring Interface (Optional)
server {
    listen 8080;
    server_name ytd.timobosafaris.com;

    # Restrict access to your servers only
    allow 127.0.0.1;        # Localhost
    allow 172.234.172.191;  # This server
    allow 34.57.68.120;     # GCP server
    allow 13.60.71.187;     # AWS server
    deny all;

    location /nginx_status {
        stub_status on;
        access_log off;
    }

    location /backend_health {
        # Check health of all backends
        return 200 "Check each backend:\ncurl http://127.0.0.1:3001/api/health\ncurl http://34.57.68.120:3001/api/health\ncurl http://13.60.71.187:3001/api/health\n";
        add_header Content-Type text/plain;
    }
}
