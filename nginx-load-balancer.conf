# Nginx Load Balancer Configuration for YouTube Downloader
# Multi-Server Setup with Independent Cookie Accounts
#
# Architecture:
#   Nginx LB → Server 1 (account_a) → Backend API + Cookie Extractor
#           → Server 2 (account_b) → Backend API + Cookie Extractor
#           → Server N (account_n) → Backend API + Cookie Extractor
#
# Installation:
#   sudo nano /etc/nginx/sites-available/ytd-loadbalancer
#   sudo ln -s /etc/nginx/sites-available/ytd-loadbalancer /etc/nginx/sites-enabled/
#   sudo nginx -t
#   sudo systemctl reload nginx

# Upstream backend servers
upstream ytd_backend {
    # Load balancing method: least_conn (send to server with fewest connections)
    # Alternatives:
    #   - round_robin (default, alternates between servers)
    #   - ip_hash (same client always goes to same server)
    #   - least_time (nginx plus only)
    least_conn;

    # Server 1 - ytd.timobosafaris.com (172.234.172.191) - Account A
    # This server also hosts the load balancer (localhost)
    server 127.0.0.1:3001 max_fails=3 fail_timeout=30s;

    # Server 2 - GCP Instance (34.57.68.120) - Account B
    server 34.57.68.120:3001 max_fails=3 fail_timeout=30s;

    # Server 3 - AWS Instance (13.60.71.187) - Account C
    server 13.60.71.187:3001 max_fails=3 fail_timeout=30s;

    # Keepalive connections to backend (improves performance)
    keepalive 32;
}

# Health check configuration
# Nginx will automatically mark servers as down if they fail health checks
# The backend /api/health endpoint returns:
#   - 200 OK if cookies available and not refreshing
#   - 503 Service Unavailable if cookies missing/refreshing

server {
    listen 80;
    server_name ytd.timobosafaris.com;

    # Redirect HTTP to HTTPS (uncomment when SSL is configured)
    # return 301 https://$server_name$request_uri;
}

# Main server block
server {
    # For testing without SSL, use port 80
    listen 80;

    # When SSL is configured, comment out port 80 above and uncomment below:
    # listen 443 ssl http2;

    server_name ytd.timobosafaris.com;

    # SSL Configuration (uncomment when ready to enable HTTPS)
    # ssl_certificate /etc/letsencrypt/live/ytd.timobosafaris.com/fullchain.pem;
    # ssl_certificate_key /etc/letsencrypt/live/ytd.timobosafaris.com/privkey.pem;
    # ssl_protocols TLSv1.2 TLSv1.3;
    # ssl_ciphers HIGH:!aNULL:!MD5;
    # ssl_prefer_server_ciphers on;

    # Logging
    access_log /var/log/nginx/ytd-lb-access.log;
    error_log /var/log/nginx/ytd-lb-error.log;

    # Client body size (for video uploads if needed)
    client_max_body_size 100M;

    # Timeouts
    proxy_connect_timeout 60s;
    proxy_send_timeout 300s;
    proxy_read_timeout 300s;

    # Proxy headers
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header Connection "";
    proxy_http_version 1.1;

    # API endpoints
    location /api/ {
        proxy_pass http://ytd_backend;

        # Enable retries on next server if current fails
        proxy_next_upstream error timeout http_503;
        proxy_next_upstream_tries 3;
        proxy_next_upstream_timeout 10s;

        # Health check via proxy_intercept_errors
        # If backend returns 503 (cookies unavailable), try next server
        proxy_intercept_errors on;
        error_page 503 = @retry_backend;
    }

    # WebSocket support for /api/ws
    location /api/ws {
        proxy_pass http://ytd_backend;

        # WebSocket upgrade headers
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # WebSocket timeout (keep connection alive)
        proxy_read_timeout 3600s;
        proxy_send_timeout 3600s;

        # WebSocket headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Retry on next server if WebSocket fails
        proxy_next_upstream error timeout http_503;
    }

    # Health check endpoint (exposed for monitoring)
    location /health {
        proxy_pass http://ytd_backend/api/health;

        # Don't retry health checks
        proxy_next_upstream off;

        # Quick timeout
        proxy_connect_timeout 5s;
        proxy_read_timeout 5s;
    }

    # Retry location for 503 errors
    location @retry_backend {
        # Try the next server in the upstream
        proxy_pass http://ytd_backend;
        proxy_next_upstream error timeout http_503;
        proxy_next_upstream_tries 2;
    }

    # Metrics endpoint (Prometheus)
    location /metrics {
        proxy_pass http://ytd_backend/metrics;

        # Don't retry metrics
        proxy_next_upstream off;
    }

    # Static files (if served by nginx)
    location /downloads/ {
        # If you want nginx to serve downloaded files directly
        alias /opt/ytdl/downloads/;

        # Or proxy to backend
        # proxy_pass http://ytd_backend/downloads/;

        # Disable for security if not needed
        # return 404;
    }

    # Root path
    location / {
        # Redirect to docs or frontend
        return 301 /api/docs;

        # Or proxy to frontend if hosted separately
        # proxy_pass http://frontend_servers;
    }
}

# Admin/monitoring interface (optional)
server {
    listen 8080;
    server_name ytd.timobosafaris.com;

    # Restrict to localhost and your servers only
    allow 127.0.0.1;        # Localhost
    allow 172.234.172.191;  # This server
    allow 34.57.68.120;     # GCP server
    allow 13.60.71.187;     # AWS server
    deny all;

    location /nginx_status {
        stub_status on;
        access_log off;
    }

    location /upstream_status {
        # Requires nginx-module-vts or similar for detailed upstream stats
        # Or use a custom status page
        return 200 "Use /health endpoint on main server\n";
        add_header Content-Type text/plain;
    }
}
